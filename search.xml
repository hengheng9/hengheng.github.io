<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/03/17/%E6%88%B3%E6%B0%94%E7%90%83/"/>
      <url>/2023/03/17/%E6%88%B3%E6%B0%94%E7%90%83/</url>
      
        <content type="html"><![CDATA[<p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。 这里的 <code>i - 1</code> 和 <code>i + 1</code> 代表和 <code>i</code> 相邻的两个气球的序号。如果 <code>i - 1</code>或 <code>i + 1</code> 超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,1,5,8]</span><br><span class="line">输出：167</span><br><span class="line">解释：</span><br><span class="line">nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []</span><br><span class="line">coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的数组，将所有气球的值放在数组的中间位置，并在两端加上值为1的虚拟气球</span></span><br><span class="line">    <span class="type">int</span> n = numsSize + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* new_nums = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    new_nums[<span class="number">0</span>] = new_nums[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        new_nums[i] = nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建二维数组dp，dp[i][j]表示戳破从i到j之间的所有气球能获得的最大硬币数量</span></span><br><span class="line">    <span class="type">int</span>** dp = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="built_in">memset</span>(dp[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">3</span>; len &lt;= n; len++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                dp[i][j] = fmax(dp[i][j], dp[i][k] + dp[k][j] + new_nums[i]*new_nums[k]*new_nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(dp);</span><br><span class="line">    <span class="built_in">free</span>(new_nums);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的时间复杂度为O(0^3)，空间复杂度为O(n^2)。</p><p>思路：首先需要将所有气球的值放在一个新数组中，并在两端加上值为1的虚拟气球，这样做的目的是让所有气球都有相邻的气球，方便计算。</p><p>接着，我们可以定义一个二维数组dp，dp[i][j]表示戳破从i到j之间的所有气球能获得的最大硬币数量。我们需要计算出dp[0][n-1]，即戳破所有气球能获得的最大硬币数量。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用python检测图像相似度</title>
      <link href="/2022/11/07/%E5%88%A9%E7%94%A8python%E6%A3%80%E6%B5%8B%E5%9B%BE%E5%83%8F%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
      <url>/2022/11/07/%E5%88%A9%E7%94%A8python%E6%A3%80%E6%B5%8B%E5%9B%BE%E5%83%8F%E7%9B%B8%E4%BC%BC%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="利用Python检测图像相似度"><a href="#利用Python检测图像相似度" class="headerlink" title="利用Python检测图像相似度"></a>利用Python检测图像相似度</h1><p>笔者最近在想能不能把该想法运用到实际工作中呢？貌似有点不切实际！！哈哈。</p><p>废话不多说，直接上代码。</p><p>思路:</p><p>根据阮一峰介绍了一个简单的图片搜索原理可以分为以下几步：</p><p>1.缩小尺寸。将图片缩小到8×8的尺寸，总共64个像素。这一步的作用是去除图片的细节，之保留结构、明暗的基本信息，丢到不同尺寸、比例带来的图片差异。</p><p>2.简化色彩。将缩小后的图片，转为64级灰度。即所有像素点一共只有64种颜色。</p><p>3.计算平均值。计算所有64个像素的灰度平均值。</p><p>4.比较像素的灰度。将每个像素的灰度，与平均值进行比较。大于或等于平均值，记做1，小于平均值，记做0。</p><p>5.计算哈希值。将上一步的比较结果组合在一起，就构成了一个64位的整数。</p><p>源代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#均值哈希算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aHash</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="comment"># 缩放为8×8</span></span><br><span class="line">    img = cv2.resize(img, (<span class="number">8</span>, <span class="number">8</span>), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">    <span class="comment"># 转换为灰度图</span></span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># s为像素和初值为0，hash_str为hash值初值为&#x27;&#x27;</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    hash_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 遍历累加求像素和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            s = s + gray[i, j]</span><br><span class="line">    <span class="comment"># 求平均灰度</span></span><br><span class="line">    avg = s / <span class="number">64</span></span><br><span class="line">    <span class="comment"># 灰度大于平均值为1相反为0生成图片的hash值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            <span class="keyword">if</span> gray[i, j] &gt; avg:</span><br><span class="line">                hash_str = hash_str + <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_str = hash_str + <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> hash_str</span><br><span class="line"><span class="comment">#差值感知算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dHash</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="comment">#缩放8×8</span></span><br><span class="line">    img=cv2.resize(img,(<span class="number">9</span>,<span class="number">8</span>),interpolation=cv2.INTER_CUBIC)</span><br><span class="line">    <span class="comment">#转换灰度图</span></span><br><span class="line">    gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    hash_str=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#每行前一个像素大于后一个像素为1，相反为0，生成哈希</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            <span class="keyword">if</span>   gray[i,j]&gt;gray[i,j+<span class="number">1</span>]:</span><br><span class="line">                hash_str=hash_str+<span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_str=hash_str+<span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> hash_str</span><br><span class="line"></span><br><span class="line"><span class="comment">#Hash值对比</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmpHash</span>(<span class="params">hash1,hash2</span>):</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    <span class="comment">#hash长度不同则返回-1代表传参出错</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(hash1)!=<span class="built_in">len</span>(hash2):</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment">#遍历判断</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(hash1)):</span><br><span class="line">        <span class="comment">#不相等则n计数+1，n最终为相似度</span></span><br><span class="line">        <span class="keyword">if</span> hash1[i]!=hash2[i]:</span><br><span class="line">            n=n+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">img1=cv2.imread(<span class="string">&#x27;A.jpg&#x27;</span>)</span><br><span class="line">img2=cv2.imread(<span class="string">&#x27;C.jpg&#x27;</span>)</span><br><span class="line">hash1= aHash(img1)</span><br><span class="line">hash2= aHash(img2)</span><br><span class="line"><span class="built_in">print</span>(hash1)</span><br><span class="line"><span class="built_in">print</span>(hash2)</span><br><span class="line">n=cmpHash(hash1,hash2)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;均值哈希算法相似度：&#x27;</span>+ <span class="built_in">str</span>(n))</span><br><span class="line"></span><br><span class="line">hash1= dHash(img1)</span><br><span class="line">hash2= dHash(img2)</span><br><span class="line"><span class="built_in">print</span>(hash1)</span><br><span class="line"><span class="built_in">print</span>(hash2)</span><br><span class="line">n=cmpHash(hash1,hash2)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;差值哈希算法相似度：&#x27;</span>+ <span class="built_in">str</span>(n))</span><br></pre></td></tr></table></figure><p>本文参考了作者阮一峰的《相似图片搜索原理》和作者Waldenz的Python OpenCV计算图片相似度的五种算法以及博主ZXJ~佳的相似度算法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2022/11/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
